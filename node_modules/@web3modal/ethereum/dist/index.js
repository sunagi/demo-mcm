import{disconnect as a,getAccount as h,watchAccount as l,fetchBalance as d,getNetwork as w,watchNetwork as u,switchNetwork as C,fetchEnsName as f,fetchEnsAvatar as m,connect as s,InjectedConnector as p}from"@wagmi/core";import{WalletConnectConnector as g}from"@wagmi/connectors/walletConnect";import{WalletConnectLegacyConnector as y}from"@wagmi/core/connectors/walletConnectLegacy";import{jsonRpcProvider as v}from"@wagmi/core/providers/jsonRpc";class N{constructor(t,n){this.wagmi={},this.walletConnectVersion=1,this.chains=[],this.namespace="eip155",this.disconnect=a,this.getAccount=h,this.watchAccount=l,this.fetchBalance=d,this.getNetwork=w,this.watchNetwork=u,this.switchNetwork=C,this.fetchEnsName=f,this.fetchEnsAvatar=m,this.wagmi=t,this.chains=n;const{isV2:e}=this.getWalletConnectConnectors();this.walletConnectVersion=e?2:1}getWalletConnectConnectors(){const t=this.wagmi.connectors.find(o=>o.id==="walletConnect"),n=this.wagmi.connectors.find(o=>o.id==="walletConnectLegacy"),e=t??n;if(!e)throw new Error("WalletConnectConnector or WalletConnectLegacyConnector is required");return{isV2:!!t,connector:e}}async connectWalletConnectV1(t,n){return new Promise((e,o)=>{t.once("message",async({type:r})=>{if(r==="connecting"){const i=(await t.getProvider()).connector;n(i.uri),i.on("disconnect",()=>{o(Error())}),i.on("connect",()=>{e()})}})})}async connectWalletConnectV2(t,n){const e=await t.getProvider();return new Promise(o=>{e.once("display_uri",r=>{n(r),o()})})}getConnectorById(t){const n=this.wagmi.connectors.find(e=>e.id===t);if(!n)throw new Error(`Connector for id ${t} was not found`);return n}getConnectors(){return this.wagmi.connectors.filter(t=>!t.id.includes("walletConnect"))}async connectWalletConnect(t,n){const{connector:e,isV2:o}=this.getWalletConnectConnectors(),r={connector:e};n&&(r.chainId=n);const i=o?this.connectWalletConnectV2.bind(this):this.connectWalletConnectV1.bind(this);return Promise.all([s(r),i(e,t)])}async connectConnector(t,n){const e={connector:this.getConnectorById(t)};return n&&(e.chainId=n),await s(e)}isInjectedProviderInstalled(){return typeof window.ethereum<"u"}safeCheckInjectedProvider(t){var n;try{const e=String(t);return!!((n=window.ethereum)!=null&&n[e])}catch(e){return console.error(e),!1}}}const I="eip155";function V({projectId:c}){return v({rpc:t=>{var n;return[1,3,4,5,10,42,56,69,97,100,137,280,324,420,42161,42220,43114,80001,421611,421613,1313161554,1313161555].includes(t.id)?{http:`https://rpc.walletconnect.com/v1/?chainId=${I}:${t.id}&projectId=${c}`}:{http:t.rpcUrls.default.http[0],webSocket:(n=t.rpcUrls.default.webSocket)==null?void 0:n[0]}}})}function j({chains:c,version:t,projectId:n}){const e=t===1,o=[new p({chains:c})];return e?o.unshift(new y({chains:c,options:{qrcode:!1}})):o.unshift(new g({chains:c,options:{projectId:n,showQrModal:!1}})),o}export{N as EthereumClient,j as w3mConnectors,V as w3mProvider};
//# sourceMappingURL=index.js.map
